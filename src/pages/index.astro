---
import { getCollection } from "astro:content";
import Layout from "../layouts/Layout.astro";
import { sectionSchemas, getFieldType, getFieldPrefix } from "../data/resume-schema";

// Build navigation structure for progress bar
interface NavItem {
  id: string;
  label: string;
  type: 'major' | 'minor';
}

// Get all resume content
const allEntries = await getCollection("resume");

// Group entries by section folder (00-personal, 01-summary, etc.)
const sections = new Map<string, { header: any; items: any[] }>();

for (const entry of allEntries) {
  const [sectionFolder] = entry.id.split("/");

  if (!sections.has(sectionFolder)) {
    sections.set(sectionFolder, { header: null, items: [] });
  }

  const section = sections.get(sectionFolder)!;
  const fileName = entry.id.split("/").pop() || "";

  if (fileName.startsWith("00-")) {
    section.header = entry;
  } else {
    section.items.push(entry);
  }
}

// Sort sections and items
const sortedSections = [...sections.entries()]
  .sort(([a], [b]) => a.localeCompare(b))
  .map(([folder, { header, items }]) => ({
    folder,
    header,
    items: items.sort((a, b) => a.id.localeCompare(b.id)),
  }));

/**
 * Section Routing - Controls where each section appears in the layout
 *
 * To ADD a new section:
 *   1. Create folder in resume/sections/ (e.g., 06-certifications/)
 *   2. Add 00-certifications.md header with type, title, sidebar, fields
 *   3. Add item files (01-cert1.md, 02-cert2.md, etc.)
 *   4. Run `npm run sync` to regenerate schema
 *
 * To MOVE section to sidebar:
 *   - Add `sidebar: true` to the section's 00-*.md header file
 *
 * To MOVE section to main content:
 *   - Remove `sidebar: true` (or set to false) in the section's 00-*.md header
 *
 * To REMOVE a section:
 *   - Delete the folder from resume/sections/
 *   - Run `npm run sync`
 *
 * Section routing logic:
 *   - type: "personal" â†’ Header (full width, top of page)
 *   - sidebar: true â†’ Left sidebar column
 *   - Everything else â†’ Main content column
 */
const headerSection = sortedSections.find(s => {
  const idx = parseInt(s.folder.split("-")[0], 10);
  return sectionSchemas[idx]?.type === "personal";
});
const sidebarSections = sortedSections.filter(s => {
  const idx = parseInt(s.folder.split("-")[0], 10);
  return sectionSchemas[idx]?.sidebar === true;
});
const mainSections = sortedSections.filter(s => {
  const idx = parseInt(s.folder.split("-")[0], 10);
  const schema = sectionSchemas[idx];
  return schema?.type !== "personal" && !schema?.sidebar;
});

// Build navigation items for progress bar (main content sections only)
const navItems: NavItem[] = [];
for (const { folder, items } of mainSections) {
  const idx = parseInt(folder.split("-")[0], 10);
  const schema = sectionSchemas[idx];
  if (!schema?.title) continue;

  // Add major node for section
  const sectionId = folder.replace(/^\d+-/, '');
  navItems.push({ id: sectionId, label: schema.title, type: 'major' });

  // Add minor nodes for items with headers (experience, projects)
  const headerField = Object.entries(schema.fields || {}).find(([_, fc]) => getFieldType(fc) === 'header')?.[0];
  if (headerField && schema.type !== 'plaintext') {
    for (const item of items) {
      const itemName = item.id.split('/').pop()?.replace(/^\d+-/, '').replace('.md', '') || '';
      const itemLabel = item.data[headerField];
      if (itemLabel) {
        navItems.push({ id: `${sectionId}-${itemName}`, label: itemLabel, type: 'minor' });
      }
    }
  }
}

// Helper to render markdown content to HTML
function renderContent(content: string): string {
  if (!content) return "";

  // Convert **bold** to <strong>
  let html = content.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");

  // Helper to clean list item text
  const cleanItem = (item: string) => item.replace(/^-\s*/, "").trim();

  // Split into sections by bold headers
  const sections = html.split(/(?=<strong>[^<]+:<\/strong>)/);

  return sections.map(section => {
    const headerMatch = section.match(/^<strong>([^<]+):<\/strong>/);
    if (headerMatch) {
      const header = headerMatch[1];
      const rest = section.replace(/^<strong>[^<]+:<\/strong>\s*/, "");
      const items = rest.split(/\n-\s*/).filter(Boolean);
      const listHtml = items.map(item => `<li>${cleanItem(item)}</li>`).join("\n");
      return `<div class="subsection"><h4>${header}</h4><ul>${listHtml}</ul></div>`;
    }
    // Plain list items
    const items = section.split(/\n-\s*/).filter(Boolean);
    if (items.length > 0) {
      const listHtml = items.map(item => `<li>${cleanItem(item)}</li>`).join("\n");
      return `<ul>${listHtml}</ul>`;
    }
    return section;
  }).join("\n");
}
---

<Layout title="Thy Do - Information Systems Engineer">
  {/* Progress Bar Navigation */}
  <nav class="progress-nav">
    <div class="progress-line"></div>
    <div class="progress-line-fill"></div>
    {navItems.map((item) => (
      <a href={`#${item.id}`} class={`progress-node progress-node--${item.type}`} data-target={item.id}>
        <span class="progress-dot"></span>
        <span class="progress-label">{item.label}</span>
      </a>
    ))}
  </nav>

  <script>
    // Progress bar scroll tracking - element visibility based
    const progressNav = document.querySelector('.progress-nav') as HTMLElement;
    const progressFill = document.querySelector('.progress-line-fill') as HTMLElement;
    const progressNodes = Array.from(document.querySelectorAll('.progress-node')) as HTMLElement[];

    // Offset from viewport edge for triggering (40%)
    const TRIGGER_OFFSET = 0.4;

    function updateProgress() {
      const windowHeight = window.innerHeight;

      // Calculate scroll progress (0 = top, 1 = bottom)
      const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
      const scrollHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;
      const scrollProgress = scrollHeight > 0 ? scrollTop / scrollHeight : 0;

      let lastVisitedIndex = -1;

      progressNodes.forEach((node, index) => {
        const targetId = node.getAttribute('data-target');
        const target = targetId ? document.getElementById(targetId) : null;

        if (target) {
          const rect = target.getBoundingClientRect();
          let isVisible = false;

          if (scrollProgress <= 0.5) {
            // Top half of content: trigger when section top is 40% from viewport top
            isVisible = rect.top <= windowHeight * TRIGGER_OFFSET;
          } else {
            // Bottom half of content: trigger when section top enters bottom 40% of viewport
            isVisible = rect.top <= windowHeight * (1 - TRIGGER_OFFSET);
          }

          if (isVisible) {
            node.classList.add('visited');
            lastVisitedIndex = index;
          } else {
            node.classList.remove('visited');
          }
        }
      });

      // Sync fill height with visited nodes
      if (progressFill && progressNav) {
        if (lastVisitedIndex >= 0 && progressNodes.length > 0) {
          const lastVisitedNode = progressNodes[lastVisitedIndex];
          const navRect = progressNav.getBoundingClientRect();
          const nodeRect = lastVisitedNode.getBoundingClientRect();
          const nodeCenter = nodeRect.top + nodeRect.height / 2 - navRect.top;
          progressFill.style.height = `${nodeCenter - 8}px`;
        } else {
          progressFill.style.height = '0';
        }
      }
    }

    // Handle click navigation - scroll so section lands at consistent position
    const JUMP_RATIO = 0.35;

    progressNodes.forEach((node) => {
      node.addEventListener('click', (e) => {
        e.preventDefault();
        const targetId = node.getAttribute('data-target');
        const target = targetId ? document.getElementById(targetId) : null;

        if (target) {
          const windowHeight = window.innerHeight;
          const targetRect = target.getBoundingClientRect();
          const scrollTop = window.scrollY;
          const targetPosition = scrollTop + targetRect.top - (windowHeight * JUMP_RATIO);

          window.scrollTo({
            top: Math.max(0, targetPosition),
            behavior: 'smooth'
          });

          // Find the element to highlight (item for minor nodes, section for major)
          const highlightTarget = target.closest('.item') || target.closest('.section') || target;
          highlightTarget.classList.remove('highlight');
          // Force reflow to restart animation
          void (highlightTarget as HTMLElement).offsetWidth;
          highlightTarget.classList.add('highlight');
        }
      });
    });

    window.addEventListener('scroll', updateProgress, { passive: true });
    updateProgress();
  </script>

  {/* Two-column layout */}
  <div class="layout">
    {/* Sidebar - Photo, Education & Skills */}
    <aside class="sidebar">
      {/* Profile Photo - add your image to public/photo.* (jpg, JPG, png, etc.) */}
      {(() => {
        // Find photo with any common extension (case-insensitive matching at build)
        const photoFiles = Object.keys(import.meta.glob('/public/photo.{jpg,JPG,jpeg,JPEG,png,PNG}', { eager: true }));
        const photoPath = photoFiles[0]?.replace('/public', '/thydo') || '/thydo/photo.jpg';
        return (
          <div class="profile-photo">
            <img src={photoPath} alt="Profile photo" />
          </div>
        );
      })()}
      {sidebarSections.map(({ folder, header, items }) => {
        const schemaIndex = parseInt(folder.split("-")[0], 10);
        const schema = sectionSchemas[schemaIndex] || {};
        const sectionType = schema.type;
        const title = schema.title;
        const fields = schema.fields || {};
        const renderAsCategories = schema.renderAsCategories;

        return (
          <section class={`section section--${sectionType}`}>
            {title && <h2>{title}</h2>}

            {items.map((item) => {
              const data = item.data;
              const content = item.body;

              {/* Skills with categories */}
              if (renderAsCategories) {
                const categoryField = Object.keys(fields)[0];
                const skills = content?.replace(/^- /gm, "").split("\n").filter(Boolean).join(", ");
                return (
                  <div class="skill-category">
                    {data[categoryField] && <h4>{data[categoryField]}</h4>}
                    <span class="skill-list">{skills}</span>
                  </div>
                );
              }

              {/* Education */}
              const headerFields = Object.entries(fields).filter(([_, fc]) => getFieldType(fc) === "header");
              const subheaderFields = Object.entries(fields).filter(([_, fc]) => getFieldType(fc) === "subheader");
              const inlineFields = Object.entries(fields).filter(([_, fc]) => getFieldType(fc) === "inline");

              return (
                <article class="item item--compact">
                  {headerFields.map(([fieldName]) => {
                    const value = data[fieldName];
                    return value ? <h3>{value}</h3> : null;
                  })}
                  {subheaderFields.map(([fieldName]) => {
                    const value = data[fieldName];
                    return value ? <p class="subheader">{value}</p> : null;
                  })}
                  <p class="inline-info">
                    {inlineFields.map(([fieldName, fieldConfig], i) => {
                      const value = data[fieldName];
                      const prefix = getFieldPrefix(fieldConfig);
                      return value ? (
                        <>
                          {i > 0 && <span class="sep">|</span>}
                          <span>{prefix}{value}</span>
                        </>
                      ) : null;
                    })}
                  </p>
                </article>
              );
            })}
          </section>
        );
      })}
    </aside>

    {/* Main Content - Header, Summary, Experience, Projects */}
    <main class="main-content">
      {/* Header - Personal Info */}
      {headerSection && (
        <header class="personal">
          {headerSection.items.map((item) => {
            const data = item.data;
            return (
              <>
                {data.name && <h1>{data.name}</h1>}
                {data.title && <p class="job-title">{data.title}</p>}
                <p class="contact">
                  {data.email && <><a href={`mailto:${data.email}`}>{data.email}</a><span class="sep">|</span></>}
                  {data.GitHub && <><a href={`https://${data.GitHub}`} target="_blank">{data.GitHub}</a><span class="sep">|</span></>}
                  {data.LinkedIn && <a href={`https://${data.LinkedIn}`} target="_blank">{data.LinkedIn}</a>}
                </p>
              </>
            );
          })}
        </header>
      )}

      {mainSections.map(({ folder, header, items }) => {
        const schemaIndex = parseInt(folder.split("-")[0], 10);
        const schema = sectionSchemas[schemaIndex] || {};
        const sectionType = schema.type;
        const title = schema.title;
        const fields = schema.fields || {};
        const sectionId = folder.replace(/^\d+-/, '');

        return (
          <section id={sectionId} class={`section section--${sectionType}`}>
            {title && <h2>{title}</h2>}

            {items.map((item) => {
              const data = item.data;
              const content = item.body;
              const itemName = item.id.split('/').pop()?.replace(/^\d+-/, '').replace('.md', '') || '';
              const itemId = `${sectionId}-${itemName}`;

              {/* Summary section */}
              if (sectionType === "plaintext") {
                return <p class="summary">{content}</p>;
              }

              {/* Experience, Projects */}
              const headerFields = Object.entries(fields).filter(([_, fc]) => getFieldType(fc) === "header");
              const subheaderFields = Object.entries(fields).filter(([_, fc]) => getFieldType(fc) === "subheader");
              const inlineFields = Object.entries(fields).filter(([_, fc]) => getFieldType(fc) === "inline");

              return (
                <article id={itemId} class="item">
                  {headerFields.map(([fieldName]) => {
                    const value = data[fieldName];
                    return value ? <h3>{value}</h3> : null;
                  })}

                  <div class="item-meta">
                    <div class="item-meta-left">
                      {subheaderFields.map(([fieldName]) => {
                        const value = data[fieldName];
                        return value ? <span class="subheader">{value}</span> : null;
                      })}
                    </div>
                    <div class="item-meta-right">
                      {inlineFields.map(([fieldName, fieldConfig], i) => {
                        const value = data[fieldName];
                        const prefix = getFieldPrefix(fieldConfig);
                        return value ? (
                          <>
                            {i > 0 && <span class="sep">|</span>}
                            <span class="inline-field">{prefix}{value}</span>
                          </>
                        ) : null;
                      })}
                    </div>
                  </div>

                  {content && <div class="content" set:html={renderContent(content)} />}
                </article>
              );
            })}
          </section>
        );
      })}
    </main>
  </div>

  <footer class="site-footer">
    <p>Made with Thy's hyperfocus and Clawdie ðŸ¦€</p>
    <a href="https://github.com/thydo/thydo" target="_blank">View source</a>
  </footer>
</Layout>

<style>
  .site-footer {
    text-align: center;
    padding: 2rem 1rem;
    margin-top: 3rem;
    font-size: 0.85rem;
    color: var(--text-secondary);
  }
  .site-footer a {
    color: var(--h2);
    text-decoration: none;
  }
  .site-footer a:hover {
    text-decoration: underline;
  }
</style>
